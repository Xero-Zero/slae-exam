#include <openssl/err.h>
#include <openssl/evp.h>
#include <openssl/conf.h>
#include <string.h>
#include <stdio.h>

void print_shellcode(unsigned char *shellcode)
{
//printf("Works");
//FILE *fp;
//fp = fopen("Output.txt", "a");
//fprintf(fp,"\"");
// printf("Comes Here\n");
  int i, len;
  char lola[32];
//  char lola[0] = '\"';
  len = strlen(shellcode);
  printf("\n[+]Print of Length: %d\n",len);
  for (i = 0; i < len; i++)
  {
//   printf("%d\n",i);
//   printf("%s", shellcode[i]);
    printf("\\x%02x", shellcode[i]);
//    sprintf(lola[i], "\\x%02x", shellcode[i]);
//    printf("%s" lola);
  }
//fprintf(fp,"\"");
    printf("\n");
//    printf("\nLola: %s", lola);
}

void tohex(unsigned char * in, size_t insz, char * out, size_t outsz)
{
    unsigned char * pin = in;
    const char * hex = "0123456789ABCDEF";
    char * pout = out;
    for(; pin < in+insz; pout +=3, pin++){
        pout[0] = hex[(*pin>>4) & 0xF];
        pout[1] = hex[ *pin     & 0xF];
        pout[2] = ':';
        if (pout + 3 - out > outsz){
            /* Better to truncate output string than overflow buffer */
            /* it would be still better to either return a status */
            /* or ensure the target buffer is large enough and it never happen */
            break;
        }
    }
    pout[-1] = 0;
}

static char *gen_random(char *str_caller, size_t size)
{
  const char charsets[] = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
  int i, w;
  w = 0;
  for (i = 0; w < size; w++)
  {
    int key = rand() % (int) (sizeof charsets - 1);
    str_caller[w] = charsets[key];
  }
  str_caller[size] = '\0';
  return str_caller;
}

int main (void)
{
  unsigned char enc_key[32];
  unsigned char i_vect[16];
  unsigned char shellcode[] = "\x31\xc0\x50\x68\x2f\x2f\x6c\x73\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80";
  unsigned char encrypted[128];
  unsigned char encrypted_final[128];
  unsigned char decrypted[128];
  int shellcode_len, encrypted_len, decrypted_len;
  shellcode_len = strlen(shellcode);
  ERR_load_crypto_strings();
  OpenSSL_add_all_algorithms();
  OPENSSL_config(NULL);
  gen_random(enc_key, 32);
  gen_random(i_vect, 16);
  encrypted_len = encrypt(shellcode, shellcode_len, enc_key, i_vect, encrypted);
//  memcpy(encrypted_final,encrypted,sizeof(encrypted));
  void tohex(unsigned char * in, size_t insz, char * out, size_t outsz)
{
    unsigned char * pin = in;
    const char * hex = "0123456789ABCDEF";
    char * pout = out;
    for(; pin < in+insz; pout +=3, pin++){
        pout[0] = hex[(*pin>>4) & 0xF];
        pout[1] = hex[ *pin     & 0xF];
        pout[2] = ':';
        if (pout + 3 - out > outsz){
            /* Better to truncate output string than overflow buffer */
            /* it would be still better to either return a status */
            /* or ensure the target buffer is large enough and it never happen */
            break;
        }
    }
    pout[-1] = 0;
}
  encrypted[encrypted_len] = '\0';
  printf("\n[+]Crypted Shellcode is %d bytes long:\n", (encrypted_len));
  print_shellcode(encrypted);
//  EVP_cleanup();
//  ERR_free_strings();

//  int enc_l = strlen(encrypted_final);
  unsigned char encoded[] ="\x36\x84\xe3\x10\xf0\x28\x74\x77\x8b\x2f\x63\xb1\xf4\xc7\x85\x91\xf3\xdb\x43\x08\x9d\x88\xce\xb2\x4f\xbb\x31\xef\xab\xc3\x33\x3b";
  int encoded_l = strlen(encoded);
  printf("%d",encoded_l);
  decrypted_len = decrypt(encoded,encoded_l, enc_key, i_vect, decrypted);
  decrypted[decrypted_len] = '\0';
  printf("\n[+]Decrypted Shellcode is %d bytes long:\n", (decrypted_len));
  print_shellcode(decrypted);
  return 0;
}

int encrypt(unsigned char *shellcode, int shellcode_len, unsigned char *key, unsigned char *iv, unsigned char *encrypted)
{
  EVP_CIPHER_CTX *ciphertext;
  int len, encrypted_len;
  ciphertext = EVP_CIPHER_CTX_new();
  EVP_EncryptInit_ex(ciphertext, EVP_aes_256_cbc(), NULL, key, iv);
  EVP_EncryptUpdate(ciphertext, encrypted, &len, shellcode, shellcode_len);
  encrypted_len = len;
  EVP_EncryptFinal_ex(ciphertext, encrypted + len, &len);
  encrypted_len += len;
  EVP_CIPHER_CTX_free(ciphertext);
  return encrypted_len;
}

int decrypt(unsigned char *encrypted, int encrypted_len, unsigned char *key, unsigned char *iv, unsigned char *decrypted)
{
  EVP_CIPHER_CTX *ciphertext; //openssl EVP ciphertext structure
  int len, decrypted_len;
  ciphertext = EVP_CIPHER_CTX_new();
  EVP_DecryptInit_ex(ciphertext, EVP_aes_256_cbc(), NULL, key, iv);
  EVP_DecryptUpdate(ciphertext, decrypted, &len, encrypted, encrypted_len); //decrypt shellcode
  decrypted_len = len; //decrypted shellcode length
  EVP_DecryptFinal_ex(ciphertext, decrypted + len, &len); //finalize encryption
  decrypted_len += len; //decrypted shellcode length
  EVP_CIPHER_CTX_free(ciphertext); //clean up
  return decrypted_len;
}

